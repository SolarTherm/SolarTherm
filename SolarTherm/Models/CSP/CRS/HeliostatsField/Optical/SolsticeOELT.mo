within SolarTherm.Models.CSP.CRS.HeliostatsField.Optical;
model SolsticeOELT "Lookup table generated by Solstice"
extends OpticalEfficiency;
    import SolarTherm.Models.CSP.CRS.HeliostatsField.Optical.SolsticePyFunc;
    import SolarTherm.Models.CSP.CRS.HeliostatsField.Optical.SolsticeStatusFunc;      
    import SI = Modelica.SIunits;
	//import nSI = Modelica.SIunits.Conversions.NonSIunits;
	//import SI = Modelica.SIunits;

    parameter SolarTherm.Types.Solar_angles angles=SolarTherm.Types.Solar_angles.dec_hra
    "Table angles"
        annotation (Dialog(group="Table data interpretation"));


	  parameter String ppath = Modelica.Utilities.Files.loadResource("modelica://SolarTherm/Resources/Library") "Absolute path to the Python script";
	  parameter String pname = "run_solstice" "Name of the Python script";
	//parameter String pfunc = "run_simul" "Name of the Python functiuon"; 

    parameter String psave = Modelica.Utilities.Files.loadResource("modelica://SolarTherm/Resources/tmp/solstice-result/demo") "the directory for saving the results"; 

    parameter String field_type = "polar" "polar or surround";
    parameter String rcv_type = "flat" "flat, cylinder, stl";  
    parameter String rcv_material = "Incoloy800H" "receiver material, Haynes230, Incoloy800H or Inconel740H";  
    parameter String HTF = "salt" "heat transfer fluid, salt or sodium";  
    parameter String fluxlimitpath = "" "directory of the flux limitation file";  

	  parameter String wea_file = Modelica.Utilities.Files.loadResource("modelica://SolarTherm/Data/Weather/example_TMY3.motab"); 
    parameter String sunshape = "buie" "Buie sunshape (buie) or pillbox sunshape (pillbox)"; 
    parameter Real sunshape_param=0.02 "csr for buie sunshape or angular size for pillbox (in deg)";  

	  parameter Integer argc =30 "Number of variables to be passed to the C function";

    //parameter Boolean single_field = true "True for single field, false for multi tower";
    //parameter Boolean concrete_tower = true "True for concrete, false for thrust tower";
    parameter Real method = 1 "method of the system deisng, 1 is design from the PB, and 2 is design from the field";
    parameter Real n_helios=1000 "Number of heliostats";
    parameter SI.HeatFlowRate Q_in_rcv = 1e6;
    parameter Real SM = 2.5 "[SYS] Real solar multiple"; 
	  parameter SI.Irradiance dni_des = 930 "DNI at design point";  
    parameter SI.Length H_rcv=10 "Receiver aperture height";
    parameter SI.Length W_rcv=10 "Receiver aperture width";
    parameter Real n_H_rcv=10 "num of grid in the vertical direction (for flux map)";
    parameter Real n_W_rcv=10 "num of grid in the horizontal/circumferetial direction (for flux map)";
    parameter nSI.Angle_deg tilt_rcv = 0 "tilt of receiver in degree relative to tower axis";
    parameter SI.Length W_helio = 10 "width of heliostat in m";
    parameter SI.Length H_helio = 10 "height of heliostat in m";
    parameter SI.Length H_tower = 100 "Tower height";
    parameter SI.Length R_tower = 0.01 "Tower diameter";
    parameter SI.Length R1=80 "distance between the first row heliostat and the tower";
    parameter Real fb=0.7 "factor to grow the field layout";
    parameter SI.Efficiency helio_refl = 0.9 "reflectivity of heliostat max =1";
    parameter SI.Angle slope_error = 2e-3 "slope error of the heliostat in mrad";
    parameter Real n_row_oelt = 3 "number of rows of the look up table (simulated days in a year)";
    parameter Real n_col_oelt = 3 "number of columns of the lookup table (simulated hours per day)";
    parameter Real n_rays = 5e6 "number of rays for the optical simulation";

    parameter String tablefile(fixed=false);
    parameter Integer tablefile_status(fixed=false);  

	// additional parameters for aiming strategy and thermal performance
	parameter Boolean run_aiming = false "[H&T] Run aiming strategy or not";
	parameter Boolean run_therm = false "[H&T] Run receiver thermal model or not";
  parameter Real f_oversize = 1. "[H&T] Field oversizing factor";
	parameter Real delta_r2=0 "[H&T] Field expanding for zone2";
	parameter Real delta_r3=0 "[H&T] Field expanding for zone3";
	parameter Integer N_bank_rec = 18 "Number of bank panels in receiver";
	parameter Integer N_fp_rec = 2 "Number of flow path";	
	parameter SI.Diameter D_tb_rec = 45e-3 "Receiver tube outer diameter";

	parameter Integer aimingstrategy(fixed=false) "Run aiming strategy or not?";
	parameter Integer therm(fixed=false) "Run receiver thermal model or not?";

  SI.Angle angle1;
  SI.Angle angle2;

  Modelica.Blocks.Tables.CombiTable2D nu_table(
    tableOnFile=true,
    tableName="optics",
    smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
    fileName=tablefile)
    annotation (Placement(transformation(extent={{12,12},{32,32}})));
  Modelica.Blocks.Sources.RealExpression angle2_input(y=to_deg(angle2))
    annotation (Placement(transformation(extent={{-38,6},{-10,26}})));

  Modelica.Blocks.Sources.RealExpression angle1_input(y=to_deg(angle1))
    annotation (Placement(transformation(extent={{-38,22},{-10,42}})));

initial equation
  if run_aiming then aimingstrategy=1;
  else aimingstrategy=0;
  end if;

  if run_therm then therm=1;
  else therm=0;
  end if;

  tablefile_status = SolsticePyFunc(ppath, pname, psave, 
      wea_file, sunshape, field_type, rcv_type, rcv_material, HTF, fluxlimitpath, argc, 
      {"method","sunshape_param","Q_in_rcv", "SM", "dni_des", "n_helios", "H_rcv", "W_rcv","n_H_rcv", "n_W_rcv", "tilt_rcv", "W_helio", "H_helio", "H_tower", "R_tower", "R1", "fb", "helio_refl","slope_error", "n_row_oelt", "n_col_oelt", "n_rays","aimingstrategy", "therm", "f_oversize", "delta_r2", "delta_r3" ,"Nb", "Nfp", "Do"}, 
      {method, sunshape_param, Q_in_rcv, SM, dni_des, n_helios, H_rcv, W_rcv, n_H_rcv, n_W_rcv, tilt_rcv, W_helio, H_helio, H_tower, R_tower, R1, fb, helio_refl, slope_error, n_row_oelt, n_col_oelt, n_rays, aimingstrategy, therm, f_oversize, delta_r2, delta_r3, N_bank_rec, N_fp_rec, D_tb_rec}
      ); 
      
  tablefile = SolsticeStatusFunc(tablefile_status, psave);

equation
  if angles==SolarTherm.Types.Solar_angles.elo_hra then
    angle1=SolarTherm.Models.Sources.SolarFunctions.eclipticLongitude(dec);
    angle2=hra;
  elseif angles==SolarTherm.Types.Solar_angles.dec_hra then
    angle1=dec;
    angle2=hra;
  elseif angles==SolarTherm.Types.Solar_angles.ele_azi then
    angle1=SolarTherm.Models.Sources.SolarFunctions.elevationAngle(dec,hra,lat);
    angle2=SolarTherm.Models.Sources.SolarFunctions.solarAzimuth(dec,hra,lat);
  else
    angle1=SolarTherm.Models.Sources.SolarFunctions.solarZenith(dec,hra,lat);
    angle2=SolarTherm.Models.Sources.SolarFunctions.solarAzimuth(dec,hra,lat);
  end if;
  nu=max(0,nu_table.y);
  connect(angle2_input.y, nu_table.u2)
    annotation (Line(points={{-8.6,16},{10,16}}, color={0,0,127}));
  connect(angle1_input.y, nu_table.u1) annotation (Line(points={{-8.6,32},{2,32},
          {2,28},{10,28}}, color={0,0,127}));


end SolsticeOELT;
// vim: ts=2:sw=2:et 
