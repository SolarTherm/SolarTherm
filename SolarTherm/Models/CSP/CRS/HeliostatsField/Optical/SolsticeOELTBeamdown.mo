within SolarTherm.Models.CSP.CRS.HeliostatsField.Optical;

model SolsticeOELTBeamdown "Lookup table generated by Solstice for a beam down system"
extends OpticalEfficiency;
    import SolarTherm.Models.CSP.CRS.HeliostatsField.Optical.SolsticePyFunc;
    import SI = Modelica.SIunits;


    parameter SolarTherm.Types.Solar_angles angles=SolarTherm.Types.Solar_angles.dec_hra
    "Table angles"
        annotation (Dialog(group="Table data interpretation"));


    parameter String field_type = "surround" "Other options are : surround";
    parameter String rcv_type = "beam_down" "other options are : flat, cylinder, stl";
	parameter String wea_file = Modelica.Utilities.Files.loadResource("modelica://SolarTherm/Data/Weather/AUS_WA_Leinster_Airport_954480_TMY.motab");

        parameter nSI.Angle_deg cpc_theta_deg=20 "CPC acceptance half angle in degree";
        parameter Real cpc_h_ratio=1 "CPC critical height ratio [0,1]";
        parameter nSI.Angle_deg rim_angle_x=80 "rim angle of the hyperboloid and heliostat field in the xOz plan in degree ]0,120?] ";
        parameter nSI.Angle_deg rim_angle_y=80 "rim angle of the hyperboloid and heliostat field in the yOz plan in degree ]0,120?] ";
        parameter Real secref_inv_eccen=0.6 "Secondary Reflector (hyperboloid) inverse eccentricity [0,1]";
        parameter SI.Length H_tower = 75 "Tower height";
        parameter Real fb=0.6 "factor to grow the field layout";
        parameter SI.Length Z_rcv=0 "Polygon receiver z position, 0 is on the ground";

    parameter SI.HeatFlowRate Q_in_rcv = 40e6;
    // heliostat field
    parameter SI.Length W_helio = 6.1 "width of heliostat in m";
    parameter SI.Length H_helio = 6.1 "height of heliostat in m";
    parameter SI.Length Z_helio = 0.0 "heliostat center z location in m";

    parameter SI.Length R1=15. "distance between the first row heliostat and the tower";

    //parameter SI.Efficiency rho_helio = 0.9 "reflectivity of heliostat max=1";
    parameter SI.Angle slope_error = 1e-3 "slope error of all reflective surfaces  in mrad";

    // secondary concentrator, cpc and receiver

    parameter SI.Length W_rcv=1.2 "Polygon receiver width";
    parameter SI.Length H_rcv=10 "Polygon receiver length";

    parameter Real cpc_nfaces=4 "2D-crossed cpc with n faces";

    parameter SI.Efficiency rho_beamdown = 0.95 "reflectivity of the secondary reflector (hyperboloid) and CPC, max=1";

    parameter Real n_row_oelt = 5 "number of rows of the look up table (simulated days in a year)";
    parameter Real n_col_oelt = 22 "number of columns of the lookup table (simulated hours per day)";
    parameter Real n_rays = 5e6 "number of rays for the optical simulation";

	parameter String ppath = Modelica.Utilities.Files.loadResource("modelica://SolarTherm/Resources/Include") "Absolute path to the Python script";
	parameter String pname = "run_solstice_beamdown" "Name of the Python script";
	parameter String pfunc = "run_simul" "Name of the Python functiuon";

    parameter String psave = Modelica.Utilities.Files.loadResource("modelica://SolarTherm/Resources/Include/solstice-result/demo") "the directory for saving the results";
        parameter Integer argc = 22 "Number of variables to be passed to the C function";

    parameter String tablefile(fixed=false);

    SI.Angle angle1;
    SI.Angle angle2;

  Modelica.Blocks.Tables.CombiTable2D nu_table(
    tableOnFile=true,
    tableName="optics",
    smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
    fileName=tablefile)
    annotation (Placement(transformation(extent={{12,12},{32,32}})));
  Modelica.Blocks.Sources.RealExpression angle2_input(y=to_deg(angle2))
    annotation (Placement(transformation(extent={{-38,6},{-10,26}})));
  Modelica.Blocks.Sources.RealExpression angle1_input(y=to_deg(angle1))
    annotation (Placement(transformation(extent={{-38,22},{-10,42}})));

initial algorithm
tablefile := SolsticePyFunc(ppath, pname, pfunc, psave, field_type, rcv_type, wea_file, argc, {"cpc_theta_deg", "cpc_h_ratio", "rim_angle_x", "rim_angle_y", "secref_inv_eccen",
"H_tower", "fb", "Z_rcv", "W_rcv", "H_rcv", "n_rays", "n_row_oelt", "n_col_oelt", "lat", "Q_in_rcv", "R1", "W_helio", "H_helio", "Z_helio", "slope_error",
"rho_beamdown", "cpc_nfaces"}, {cpc_theta_deg, cpc_h_ratio, rim_angle_x, rim_angle_y, secref_inv_eccen, H_tower, fb, Z_rcv, W_rcv,
H_rcv, n_rays, n_row_oelt, n_col_oelt, lat, Q_in_rcv, R1, W_helio, H_helio, Z_helio, slope_error, rho_beamdown, cpc_nfaces});

equation
  if angles==SolarTherm.Types.Solar_angles.elo_hra then
    angle1=SolarTherm.Models.Sources.SolarFunctions.eclipticLongitude(dec);
    angle2=hra;
  elseif angles==SolarTherm.Types.Solar_angles.dec_hra then
    angle1=dec;
    angle2=hra;
  elseif angles==SolarTherm.Types.Solar_angles.ele_azi then
    angle1=SolarTherm.Models.Sources.SolarFunctions.elevationAngle(dec,hra,lat);
    angle2=SolarTherm.Models.Sources.SolarFunctions.solarAzimuth(dec,hra,lat);
  else
    angle1=SolarTherm.Models.Sources.SolarFunctions.solarZenith(dec,hra,lat);
    angle2=SolarTherm.Models.Sources.SolarFunctions.solarAzimuth(dec,hra,lat);
  end if;
  nu=max(0,nu_table.y);
  connect(angle2_input.y, nu_table.u2)
    annotation (Line(points={{-8.6,16},{10,16}}, color={0,0,127}));
  connect(angle1_input.y, nu_table.u1) annotation (Line(points={{-8.6,32},{2,32},
          {2,28},{10,28}}, color={0,0,127}));



end SolsticeOELTBeamdown;
