#! /bin/env python

from solartherm.dakota import gen_dakota_in, gen_interface_bb
from solartherm import simulation
import multiprocessing as mp
import numpy as np
import time
import os
import argparse
import itertools

if __name__=='__main__':
	parser = argparse.ArgumentParser()	

	parser.add_argument('file',
			help='model file name')	
	parser.add_argument('-v', action='store_true',
			help='verbose')
	parser.add_argument('--step', type=str, default='5m',
			help='simulation time step: <number>[,y,d,m,s]')
	parser.add_argument('--tolerance', type=str, default='1e-04',
			help='simulation tolerance: <number>')
	parser.add_argument('--initStep', type=str, default=None,
			help='simulation initial step size used by dassl and ida methods: <number>[,y,d,m,s]')
	parser.add_argument('--maxStep', type=str, default=None,
			help='simulation maximum absolute step size used by dassl and ida methods: <number>[,y,d,m,s]')
	parser.add_argument('--integOrder', type=str, default='5',
			help='simulation maximum integration order used by dassl and ida methods: <number>')
	parser.add_argument('--solver', type=str, default='dassl',
			help='solver choice for OpenModelica')
	parser.add_argument('--nls', type=str, default='homotopy',
			help='non-linear solver choice for OpenModelica e.g. newton, hybrid, kinsol, mixed, and homotopy')
	parser.add_argument('--np', type=int, default=mp.cpu_count(),
			help='number of processes (set to 0 for serial mode)')	
	parser.add_argument('--lv', type=str, default='-LOG_SUCCESS,-stdout',
			help='a comma-separated String list specifing which logging levels to enable, e.g. LOG_DASSL,LOG_SOLVER etc')

	parser.add_argument('--mode', type=str, default='uncertainty',
			help='type of study: uncertainty, parametric or optimisation')
	parser.add_argument('--sample', type=str, default='lhs',
			help='sampling method, e.g. lhs or random')
	parser.add_argument('--ns', type=int, default=10,
			help='number of samples')
	parser.add_argument('--dist', type=str, default='uniform',
			help='distribution of variables, e.g. uniform, normal, beta etc')
	parser.add_argument('par', metavar='P', type=str, nargs='*',
			help='parameters with bounds and optional starting value in form PNAME=LOW,HIGH[,START]')
	parser.add_argument('--wd', type=str, default='.',
			help='the working directory')

	args = parser.parse_args()

	par_n = [] # names
	par_b = [] # bounds
	for pp in args.par:
		k, v = pp.split('=')
		par_n.append(k)
		vals = [(vv) for vv in v.split(',')]
		assert len(vals) >= 2, 'Expected parameter bounds + optional start value'
		lb = vals[0]
		ub = vals[1]
		assert lb <= ub, 'Lower bound greater than upper bound'
		par_b.append([lb, ub])

	fn=os.path.abspath(args.file)
	if not os.path.exists(args.wd):
		os.makedirs(args.wd)	
	if not os.path.isabs(args.wd):
		savedir=os.path.join(os.getcwd(),args.wd)
	else:
		savedir=args.wd

	gen_dakota_in(mode=args.mode, sample_type=args.sample, num_sample=args.ns, dist_type=args.dist, var_num=len(par_n), var_names=par_n, var_vals=par_b,mofn=fn, savedir=savedir)
	gen_interface_bb(savedir)

	os.system('chmod a+x %s/interface_bb.py'%savedir)

	os.chdir(args.wd)
	if args.np!=0:
		sim = simulation.Simulator(fn=fn, fusemount=False)
		sim.compile_model()
		sim.compile_sim(args=['-s'])
		os.system('mpirun -np %s dakota -i sample.in -o sample.out > sample.stdout'%args.np)
	else:
		os.system('dakota -i sample.in -o sample.out > sample.stdout')

	

	


	
