#! /bin/env python
from __future__ import division
import argparse
import os
import functools
from solartherm import postproc
from solartherm import simulation
from solartherm.optimisation import *

import numpy as np

import time

#import multiprocessing

import matplotlib.pyplot as plt

t_start = time.time()


def objective_function(sim, mat_fn, stime, initStep, maxStep, integOrder, solver, nls, lv, verb, scale, offset, perf_i, par_n, resultclass, op_meth, frwk, sign, par_val):

	par_v = [str(v*scale[i] + offset[i]) for i, v in enumerate(par_val)]
	sim.update_pars(par_n, par_v)
	sim.simulate(start=stime[0], stop=stime[1], step=stime[2], initStep=initStep, maxStep=maxStep, integOrder=integOrder, solver=solver, nls=nls, lv=lv)

	res = resultclass(mat_fn)
	constr, distance = res.constrained_optimisation() # constr is true if optimisattion is constrained. distance to be added to a constant penalty offset

	if frwk == "soo_min": # Single-objective optimisation to minimise an objective
		obj_min = res.calc_perf()[perf_i[0]] # The objective to be minimised (i.e. lcoe or lcof)

		if constr:
			obj_min = 9.999e+99 + distance
			print "A constraint is violated at this design point!"

		if verb:
			print(par_v)
			print(obj_min)

		if op_meth == 'ga2':
			return obj_min,
		else:
			return obj_min

	elif frwk == "soo_max": # Single-objective optimisation to maximise an objective
		obj_max = res.calc_perf()[perf_i[0]] # The objective to be maximised (i.e. epy, capf or srev)

		if constr:
			obj_max = -9.999e+99 - distance
			print "A constraint is violated at this design point!"

		if verb:
			print(par_v)
			print(obj_max)

		if op_meth == 'ga2':
			return obj_max,
		else:
			return sign * obj_max
	else: # Multi-objective optimisation
		assert(frwk == "moo"), "The framework specified for optimisation must be one of soo_min, soo_max, or moo!"
		if perf_i[0] == 1:
			obj_min = res.calc_perf()[perf_i[0]]
			obj_max = res.calc_perf()[perf_i[1]]
		else:
			obj_min = res.calc_perf()[perf_i[1]]
			obj_max = res.calc_perf()[perf_i[0]]

		if constr:
			obj_min = 9.999e+99 + distance
			obj_max = -9.999e+99 - distance
			print "A constraint is violated at this design point!"

		if verb:
			print(par_v)
			print(obj_min, obj_max)

		return obj_min, \
		obj_max


if __name__ == '__main__':
	"""
	Should make sure parameters are not final (protected), or that other
	derived parameters are final.
	"""
	parser = argparse.ArgumentParser()
	parser.add_argument('file',
			help='model file name')
	parser.add_argument('-v', action='store_true',
			help='verbose')
	parser.add_argument('--nomc', action='store_true',
			help='no model compilation')
	parser.add_argument('--nosc', action='store_true',
			help='no simulation compilation')
	parser.add_argument('--noc', action='store_true',
			help='no compilation at all (--nomc and --nosc)')
	parser.add_argument('--start', type=str, default='0',
			help='simulation start time: <number>[,y,d,m,s]')
	parser.add_argument('--stop', type=str, default='1y',
			help='simulation stop time: <number>[,y,d,m,s]')
	parser.add_argument('--step', type=str, default='5m',
			help='simulation time step: <number>[,y,d,m,s]')
	parser.add_argument('--initStep', type=str, default=None,
			help='simulation initial step size used by dassl and ida methods: <number>[,y,d,m,s]')
	parser.add_argument('--maxStep', type=str, default=None,
			help='simulation maximum absolute step size used by dassl and ida methods: <number>[,y,d,m,s]')
	parser.add_argument('--integOrder', type=str, default='5',
			help='simulation maximum integration order used by dassl and ida methods: <number>')
	parser.add_argument('--solver', type=str, default='dassl',
			help='solver choice for OpenModelica')
	parser.add_argument('--nls', type=str, default='homotopy',
			help='non-linear solver choice for OpenModelica e.g. newton, hybrid, kinsol, mixed, and homotopy')
	parser.add_argument('--lv', type=str, default='-LOG_SUCCESS,-stdout',
			help='a comma-separated String list specifing which logging levels to enable, e.g. LOG_DASSL,LOG_SOLVER etc')
	parser.add_argument('--method', type=str, default='Nelder-Mead',
			help='pso,  cma, ga1, ga2, nsga2 or one of the scipy optimisation methods')
	parser.add_argument('--maxiter', type=int, default=20,
			help='maximum number of iterations (not necessarily number of simulations)')
	parser.add_argument('--objective', type=str, default='lcoe',
			help='quantity to conduct a single (i.e. minimisation or maximisation) or multi-objective optimisation (produced by post processing) in form of objective=lcoe,capf')
	parser.add_argument('par', metavar='P', type=str, nargs='*',
			help='parameters with bounds and optional starting value in form PNAME=LOW,HIGH[,START]')
	parser.add_argument('--fuel', action='store_true',
			help='run post-processing calculations for levelised cost of fuel')
	parser.add_argument('--framework', type=str, default='soo_min',
			help='soo_min, soo_max or moo, being single objective minimisation, single objective maximisation, or multi-objective optimisation respectively')
	parser.add_argument('--outfile_f',  type=str, default=None,
			help='save final optimal solution and objective(s) to outfile_f')
	parser.add_argument('--outfig',  type=str, default=None,
			help='save figure to outfig instead of displaying')
	parser.add_argument('--outfile_p',  type=str, default=None,
			help='save pareto optimal solutions of multi-objective optimisation to outfile_p')
	parser.add_argument('--dm',  type=str, default='linmap',
			help='Decision-making methods for the multi-objective optimisation framework: linmap, topsis')
	args = parser.parse_args()



	sim = simulation.Simulator(args.file);

	if not args.noc:
		if not args.nomc:
			print('Compiling model')
			sim.compile_model()
		if not args.nosc:
			print('Compiling simulator')
			sim.compile_sim(args=([] if args.v else ['-s']))

	if args.fuel:
		resultclass = postproc.SimResultFuel
	else:
		resultclass = postproc.SimResultElec

	op_meth = args.method
	frwk = args.framework

	if args.framework == "soo_max" and op_meth not in ["ga1", "ga2"]:
		sign = -1.0
	else:
		sign = 1.0

	if args.framework == "moo":
		decisionmaker= postproc.DecisionMaker # Decision-maker classs instance
		dm_method = args.dm

	sim.load_init()

	par_n = [] # names
	par_b = [] # bounds
	par_0 = [] # start
	offset = []
	scale = []
	# Don't need bounds (pass None for variable to minimize)
	for pp in args.par:
		k, v = pp.split('=')
		par_n.append(k)
		vals = [simulation.parse_var_val(vv, sim.get_unit(k))
			for vv in v.split(',')]
		assert len(vals) >= 2, 'Expected parameter bounds + optional start value'
		lb = vals[0]
		ub = vals[1]
		assert lb <= ub, 'Lower bound greater than upper bound'
		#par_b.append([lb, ub])
		p0 = (ub + lb)/2
		if len(vals) == 3:
			p0 = vals[2]
		#par_0.append(p0)
		offset.append(lb)
		scale.append((ub - lb))
		par_b.append([0, 1])
		par_0.append((p0 - lb)/(ub - lb))

	mat_fn = sim.model + '_res.mat'

	try:
		obj_n = args.objective.split(",") # A list of objective(s) name in string
		perf_i = [] # perfromance index
		for oo in obj_n:
			perf_i.append(resultclass.perf_n.index(oo))
	except ValueError:
		raise ValueError('Objective(s) value should be in '
				+ str(resultclass.perf_n))

	objfunc = functools.partial(objective_function, sim, mat_fn,
			(args.start, args.stop, args.step), args.initStep,
			args.maxStep, args.integOrder, args.solver, args.nls, args.lv,
			args.v, scale, offset, perf_i, par_n, resultclass, op_meth, frwk, sign)

	print "\n\n\nOptimisation parameter(s): ", par_n, "\n\n\n"

	if args.framework in ['soo_min', 'soo_max']:

		if args.method == 'pso':
			res, cand=st_pso(objfunc, par_b, args.maxiter, scale, offset, args.framework, args.outfile_f)

		elif args.method == 'cma':
			res, cand=st_cma(objfunc, par_b, par_0, args.maxiter, scale, offset, args.framework, args.outfile_f)

		elif args.method == 'ga1':
			res, cand=st_ga1(objfunc, par_b, par_n, args.framework, args.outfile_f)

		elif args.method == 'ga2':
			st_ga2(objfunc, par_b, par_n, args.framework, args.outfile_f)

		else: # Use one of the scipy optimisation methods. For single-objective maximisation use one of L-BFGS-B, TNC or SLSQP.
			res, cand= st_sciopt(objfunc, op_meth, par_b, par_0, args.maxiter, scale, offset, args.framework, args.outfile_f)

	else:
		assert(frwk == "moo"), "The framework specified for optimisation must be one of soo_min, soo_max, or moo!"	
		if args.method == 'nsga2':		

			st_nsga2(objfunc, obj_n, par_b, par_n, scale, offset, dm_method, decisionmaker, args.outfile_p, args.outfile_f)
			# Plot the Pareto Front
			fig = plt.figure()
			fig.add_subplot(111)

			plt.scatter(front[:,0], front[:,1], c="b", marker='*')
			plt.title('Pareto Front', loc='center')
			plt.axis("tight")
			if perf_i[0] == 1:
				obj_min_u = resultclass.perf_u[perf_i[0]] # objective unit
				obj_max_u = resultclass.perf_u[perf_i[1]] # objective unit
			else:
				obj_min_u = resultclass.perf_u[perf_i[1]] # objective unit
				obj_max_u = resultclass.perf_u[perf_i[0]] # objective unit
			plt.xlabel(obj_n[0] + " (" + obj_min_u + ")")
			plt.ylabel(obj_n[1] + " (" + obj_max_u + ")")
			plt.grid(True,color='0.5', linestyle='--', linewidth=0.5)
			if args.outfig is not None:
				fig.savefig(args.outfig, dpi=600) # Example: outfig = ../examples/ParetoFront.png
			else:
				plt.show(block=True)
	
		else:
			print "nsga2 is the only optimisation method implemented for the multi-objective optimisation framework"
