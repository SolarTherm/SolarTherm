#!@PYTHON_SHEBANG@
from __future__ import print_function
from __future__ import unicode_literals 

# TODO note that distutils has the feature of correcting the shebang of installed scripts. we should used distutils to sort out this file, therefore.

# SolarTherm invocation script
# This is an alternative to the current 'st_local_env' thing, which seems to be
# unnecessarily complicated for new users. The idea is for this single script
# to be installed on the user's PATH, and then for all SolarTherm scripts to
# run 'through' this wrapper script. For example 'st_simulate' becomes 'st simulate'
# with no underscore.

# A complication with 'st' is that on Windows, we don't recognise the SHEBANG
# comment at the top of our scripts as a way of telling the shell that this
# is Python script. For that case, this script sets env var SOLARTHERM_SHELL as 
# the command that must be used to run this script again in a nested process. We 
# need that in order to be able to run tools like st_wea_to_mo from inside
# OpenModelica.

import os, subprocess, sys, platform, re, shutil

NEWENV = dict(os.environ)
		
def CYG(path):
	"""Convert a MSYS path to a native Windows path, where necessary."""
	if not platform.system() == "Windows":
		return path # no action required on Linux
	if not os.environ.get("MSYSTEM"):
		print("This script must be run from inside an MSYS MINGW64 prompt")
		sys.exit(2)
	return subprocess.check_output(['cygpath','-w',path],encoding='utf-8').strip()

def PJ(*args):
	"""Join paths in a PATH-like environment variable using this platform's separator char."""
	return os.pathsep.join(args)

def PS(val):
	"""Split a PATH-like variable into a list. FIXME possible escaping?"""
	return val.split(os.pathsep)

def prepend(newenv,path,envvar):
	pp = newenv.get(envvar)
	if pp is not None:
		path = PJ(path,pp)
	newenv[envvar] = path

def append(newenv,path,envvar):
	pp = newenv.get(envvar)
	if pp is not None:
		path = PJ(pp,path)
	newenv[envvar] = path

instp = CYG('@PREFIX@')
NEWENV['INSTALL_PREFIX'] = instp
assert os.environ.get('HOME')
omlibp = os.path.join(instp,"lib","omlibrary")

#PYEXE = CYG(os.path.normpath(shutil.which('@PYTHON@')))

NEWENV['OPENMODELICALIBRARY']=PJ(
	CYG(os.path.join(os.path.expandvars("$HOME"),".openmodelica","libraries"))
	,CYG(omlibp)
	,CYG("/usr/lib/omlibrary")
	,CYG("/usr/local/lib/omlibrary")
)

# TODO: later, we may put st_simulate etc someone OFF the path, and in that case
# we will have to chage the invocation.
#prepend(os.path.expandvars("$INSTALL_PREFIX/bin"),"PATH")

version=sys.version_info[:2]
pyp = os.path.join(instp,"lib","python{0}.{1}/site-packages".format(*version))
append(NEWENV,pyp,'PYTHONPATH')

libp = os.path.join(instp,"lib")
prepend(NEWENV,libp,'LD_LIBRARY_PATH')
#prepend(libp,'LIBRARY_PATH')
if platform.system()=="Windows":
	resp = os.path.join(omlibp,"SolarTherm","Resources","Library")
	prepend(NEWENV,resp,'PATH')
	prepend(NEWENV,CYG('/mingw64'),'PYTHONHOME')
	#print("PYTHONHOME=",os.environ.get('PYTHONHOME'))

if os.environ.get('VERBOSE'):
	for v in ['OPENMODELICALIBRARY','PATH','LD_LIBRARY_PATH','LIBRARY_PATH']:
		print(v,"=",NEWENV.get(v))

cmds = ['env','python','simulate','optimise','inspect','plotmat','cost','conv_sam_ourly','wea_to_mo']

if len(sys.argv) == 1 or sys.argv[1] == "--help":
	print("'st' is a helper script for running SolarTherm tools. It should be")
	print("followed by a sub-command, eg \"st simulate\". The valid sub-commands")
	print("are:")
	print("    %s"%("\n    ".join(cmds)))
	print("For help with sub-commands, type eg \"st simulate --help\"")
	sys.exit(0)

NEWENV['SOLARTHERM_SHELL'] = " ".join([sys.executable,os.path.join(instp,"bin","st")])

if len(sys.argv) == 2 and sys.argv[1] == '--version':
	import solartherm
	print("SolarTherm",solartherm.__version__)
	showvars = ['PATH','PYTHONPATH']
	if platform.system()=="Linux":
		showvars += ['LD_LIBRARY_PATH']
	for v in showvars:
		print(v,"=",os.environ.get(v))
	sys.exit(0)

if sys.argv[1] not in cmds:
	print("Invalid sub-command '%s'. Type \"st --help`\" for a list of valid options."%(sys.argv[1]))
	sys.exit(1)

if sys.argv[1] == 'env':
	shargs = []
	if os.environ.get('SOLARTHERM_SHELL'):
		raise RuntimeError("You are already inside a SolarTherm shell")
	default_ps1 = r'\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
	ps1 = os.environ.get('PS1',default_ps1)
	if re.search(re.escape(r'\]\n\[\e[32m\]\u@\h'),ps1):
		# correctly annotate the multi-line msys default prompt
		ps1,n = re.subn(re.escape(r'\n'),'\\nst> ',ps1,count=1)
		assert n==1
	else:
		# otherwise just add at the start
		ps1 = 'st> ' + ps1
	NEWENV['PS1'] = ps1
	
	if os.environ.get('VERBOSE'):
		print("Entering st env")
		print("PATH=",NEWENV.get('PATH'))
		print("LD_LIBBRAY_PATH=",NEWENV.get('LD_LIBRARY_PATH'))
		print("which bash?",shutil.which('bash'))

	if 'STBASHRC' not in os.environ:
		shargs += ['--norc']

	call = ['bash'] + shargs

elif sys.argv[1] == 'python':
	call = [sys.executable]
else:
	scr = 'st_%s'%(sys.argv[1])
	call = [sys.executable,os.path.join(instp,"bin",scr)]

if os.environ.get('VERBOSE'):
	print("CALL =",call)
	print("ARGS =",sys.argv[2:])

try:
	res = subprocess.call(call + sys.argv[2:],env=NEWENV)
except FilenotFoundError as e:
	raise RuntimeError("File not found running \"%s\""%(" ".join(call+sys.argv[2:]),))
	
sys.exit(res)

# vim: ts=4:sw=4:tw=80:noet:syntax=python

