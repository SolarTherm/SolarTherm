#!@PYTHON_SHEBANG@
from __future__ import print_function
from __future__ import unicode_literals 

# TODO note that distutils has the feature of correcting the shebang of installed scripts. we should used distutils to sort out this file, therefore.

# SolarTherm invocation script
# This is an alternative to the current 'st_local_env' thing, which seems to be
# unnecessarily complicated for new users. The idea is for this single script
# to be installed on the user's PATH, and then for all SolarTherm scripts to
# run 'through' this wrapper script. For example 'st_simulate' becomes 'st simulate'
# with no underscore.

import os, subprocess, sys, platform, re, shutil
		
def CYG(path):
	"""Convert a MSYS path to a native Windows path, where necessary."""
	if not platform.system() == "Windows":
		return path # no action required on Linux
	if not os.environ.get("MSYSTEM"):
		print("This script must be run from inside an MSYS MINGW64 prompt")
		sys.exit(2)
	return subprocess.check_output(['cygpath','-w',path],encoding='utf-8').strip()

def PJ(*args):
	"""Join paths in a PATH-like environment variable using this platform's separator char."""
	return os.pathsep.join(args)

def PS(val):
	"""Split a PATH-like variable into a list. FIXME possible escaping?"""
	return val.split(os.pathsep)

def prepend(path,envvar):
	pp = os.environ.get(envvar)
	if pp is not None:
		path = PJ(path,pp)
	os.environ[envvar] = path

def append(path,envvar):
	pp = os.environ.get(envvar)
	if pp is not None:
		path = PJ(pp,path)
	os.environ[envvar] = path

instp = CYG('@PREFIX@')
os.environ['INSTALL_PREFIX'] = instp
assert os.environ.get('HOME')
omlibp = os.path.join(instp,"lib","omlibrary")

PYEXE = CYG(os.path.normpath(shutil.which('@PYTHON@')))

os.environ['OPENMODELICALIBRARY']=PJ(
	CYG(os.path.join(os.path.expandvars("$HOME"),".openmodelica","libraries"))
	,CYG(omlibp)
	,CYG("/usr/lib/omlibrary")
	,CYG("/usr/local/lib/omlibrary")
)

# TODO: later, we may put st_simulate etc someone OFF the path, and in that case
# we will have to chage the invocation.
#prepend(os.path.expandvars("$INSTALL_PREFIX/bin"),"PATH")

version=sys.version_info[:2]
pyp = os.path.join(instp,"lib","python{0}.{1}/site-packages".format(*version))
append(pyp,'PYTHONPATH')

libp = os.path.join(instp,"lib")
prepend(libp,'LD_LIBRARY_PATH')
#prepend(libp,'LIBRARY_PATH')
if platform.system()=="Windows":
	resp = os.path.join(omlibp,"SolarTherm","Resources","Library")
	prepend(resp,'PATH')
	#prepend(CYG('/mingw64'),'PYTHONHOME')
	print("PYTHONHOME=",os.environ.get('PYTHONHOME'))

if os.environ.get('VERBOSE'):
	for v in ['OPENMODELICALIBRARY','PATH','LD_LIBRARY_PATH','LIBRARY_PATH']:
		print(v,"=",os.environ.get(v))

cmds = ['env','python','simulate','optimise','inspect','plotmat','cost','conv_sam_ourly','wea_to_mo']

if len(sys.argv) == 1 or sys.argv[1] == "--help":
	print("'st' is a helper script for running SolarTherm tools. It should be")
	print("followed by a sub-command, eg \"st simulate\". The valid sub-commands")
	print("are:")
	print("    %s"%("\n    ".join(cmds)))
	print("For help with sub-commands, type eg \"st simulate --help\"")
	sys.exit(0)

if sys.argv[1] not in cmds:
	print("Invalid sub-command '%s'. Type \"st --help`\" for a list of valid options."%(sys.argv[1]))
	sys.exit(1)

if sys.argv[1] == 'env':
	shargs = []
	if os.environ.get('SOLARTHERM_SHELL'):
		raise RuntimeError("You are already inside a SolarTherm shell")
	default_ps1 = r'\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
	ps1 = os.environ.get('PS1',default_ps1)
	if re.search(re.escape(r'\]\n\[\e[32m\]\u@\h'),ps1):
		# correctly annotate the multi-line msys default prompt
		ps1,n = re.subn(re.escape(r'\n'),'\\nst> ',ps1,count=1)
		assert n==1
	else:
		# otherwise just add at the start
		ps1 = 'st> ' + ps1
	os.environ['PS1'] = ps1
		
	shargs += ['--norc']
	os.environ['SOLARTHERM_SHELL'] = '1'
	call = ['bash'] + shargs

else:
	# TODO, we may be able to gradually migrate to st_simulate etc not being installed
	# in the path. 
	if sys.argv[1] == 'python':
		call = [PYEXE]
	else:
		scr = 'st_%s'%(sys.argv[1])
		if platform.system() == "Windows":
			call = [PYEXE,os.path.join(instp,"bin",scr)]
		else:
			call = [scr]

if os.environ.get('VERBOSE'):
	print("CALL =",call)
	print("ARGS =",sys.argv[2:])

res = subprocess.call(call + sys.argv[2:])
sys.exit(res)

# vim: ts=4:sw=4:tw=80:noet:syntax=python

